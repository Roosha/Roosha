// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: roosha_service.proto

#ifndef PROTOBUF_roosha_5fservice_2eproto__INCLUDED
#define PROTOBUF_roosha_5fservice_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "commons.pb.h"
// @@protoc_insertion_point(includes)

namespace roosha {
namespace translation {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_roosha_5fservice_2eproto();
void protobuf_AssignDesc_roosha_5fservice_2eproto();
void protobuf_ShutdownFile_roosha_5fservice_2eproto();

class Translation;
class TranslationRequest;
class Translations;
class UserTranslationsProposal;

enum TranslationProvider {
  UNKNOWN = 0,
  YANDEX_DICTIONARY = 1,
  YANDEX_TRANSLATOR = 2,
  TranslationProvider_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TranslationProvider_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TranslationProvider_IsValid(int value);
const TranslationProvider TranslationProvider_MIN = UNKNOWN;
const TranslationProvider TranslationProvider_MAX = YANDEX_TRANSLATOR;
const int TranslationProvider_ARRAYSIZE = TranslationProvider_MAX + 1;

const ::google::protobuf::EnumDescriptor* TranslationProvider_descriptor();
inline const ::std::string& TranslationProvider_Name(TranslationProvider value) {
  return ::google::protobuf::internal::NameOfEnum(
    TranslationProvider_descriptor(), value);
}
inline bool TranslationProvider_Parse(
    const ::std::string& name, TranslationProvider* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TranslationProvider>(
    TranslationProvider_descriptor(), name, value);
}
// ===================================================================

class TranslationRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:roosha.translation.TranslationRequest) */ {
 public:
  TranslationRequest();
  virtual ~TranslationRequest();

  TranslationRequest(const TranslationRequest& from);

  inline TranslationRequest& operator=(const TranslationRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TranslationRequest& default_instance();

  enum TokenOrIdCase {
    kToken = 1,
    kId = 100,
    TOKENORID_NOT_SET = 0,
  };

  void Swap(TranslationRequest* other);

  // implements Message ----------------------------------------------

  inline TranslationRequest* New() const { return New(NULL); }

  TranslationRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TranslationRequest& from);
  void MergeFrom(const TranslationRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TranslationRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes token = 1;
  private:
  bool has_token() const;
  public:
  void clear_token();
  static const int kTokenFieldNumber = 1;
  const ::std::string& token() const;
  void set_token(const ::std::string& value);
  void set_token(const char* value);
  void set_token(const void* value, size_t size);
  ::std::string* mutable_token();
  ::std::string* release_token();
  void set_allocated_token(::std::string* token);

  // optional uint64 id = 100;
  private:
  bool has_id() const;
  public:
  void clear_id();
  static const int kIdFieldNumber = 100;
  ::google::protobuf::uint64 id() const;
  void set_id(::google::protobuf::uint64 value);

  // optional string source = 2;
  void clear_source();
  static const int kSourceFieldNumber = 2;
  const ::std::string& source() const;
  void set_source(const ::std::string& value);
  void set_source(const char* value);
  void set_source(const char* value, size_t size);
  ::std::string* mutable_source();
  ::std::string* release_source();
  void set_allocated_source(::std::string* source);

  TokenOrIdCase tokenOrId_case() const;
  // @@protoc_insertion_point(class_scope:roosha.translation.TranslationRequest)
 private:
  inline void set_has_token();
  inline void set_has_id();

  inline bool has_tokenOrId() const;
  void clear_tokenOrId();
  inline void clear_has_tokenOrId();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr source_;
  union TokenOrIdUnion {
    TokenOrIdUnion() {}
    ::google::protobuf::internal::ArenaStringPtr token_;
    ::google::protobuf::uint64 id_;
  } tokenOrId_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_roosha_5fservice_2eproto();
  friend void protobuf_AssignDesc_roosha_5fservice_2eproto();
  friend void protobuf_ShutdownFile_roosha_5fservice_2eproto();

  void InitAsDefaultInstance();
  static TranslationRequest* default_instance_;
};
// -------------------------------------------------------------------

class UserTranslationsProposal : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:roosha.translation.UserTranslationsProposal) */ {
 public:
  UserTranslationsProposal();
  virtual ~UserTranslationsProposal();

  UserTranslationsProposal(const UserTranslationsProposal& from);

  inline UserTranslationsProposal& operator=(const UserTranslationsProposal& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserTranslationsProposal& default_instance();

  enum TokenOrIdCase {
    kToken = 1,
    kId = 100,
    TOKENORID_NOT_SET = 0,
  };

  void Swap(UserTranslationsProposal* other);

  // implements Message ----------------------------------------------

  inline UserTranslationsProposal* New() const { return New(NULL); }

  UserTranslationsProposal* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserTranslationsProposal& from);
  void MergeFrom(const UserTranslationsProposal& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UserTranslationsProposal* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes token = 1;
  private:
  bool has_token() const;
  public:
  void clear_token();
  static const int kTokenFieldNumber = 1;
  const ::std::string& token() const;
  void set_token(const ::std::string& value);
  void set_token(const char* value);
  void set_token(const void* value, size_t size);
  ::std::string* mutable_token();
  ::std::string* release_token();
  void set_allocated_token(::std::string* token);

  // optional uint64 id = 100;
  private:
  bool has_id() const;
  public:
  void clear_id();
  static const int kIdFieldNumber = 100;
  ::google::protobuf::uint64 id() const;
  void set_id(::google::protobuf::uint64 value);

  // optional .roosha.translation.Translations proposedTranslations = 2;
  bool has_proposedtranslations() const;
  void clear_proposedtranslations();
  static const int kProposedTranslationsFieldNumber = 2;
  const ::roosha::translation::Translations& proposedtranslations() const;
  ::roosha::translation::Translations* mutable_proposedtranslations();
  ::roosha::translation::Translations* release_proposedtranslations();
  void set_allocated_proposedtranslations(::roosha::translation::Translations* proposedtranslations);

  TokenOrIdCase tokenOrId_case() const;
  // @@protoc_insertion_point(class_scope:roosha.translation.UserTranslationsProposal)
 private:
  inline void set_has_token();
  inline void set_has_id();

  inline bool has_tokenOrId() const;
  void clear_tokenOrId();
  inline void clear_has_tokenOrId();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::roosha::translation::Translations* proposedtranslations_;
  union TokenOrIdUnion {
    TokenOrIdUnion() {}
    ::google::protobuf::internal::ArenaStringPtr token_;
    ::google::protobuf::uint64 id_;
  } tokenOrId_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_roosha_5fservice_2eproto();
  friend void protobuf_AssignDesc_roosha_5fservice_2eproto();
  friend void protobuf_ShutdownFile_roosha_5fservice_2eproto();

  void InitAsDefaultInstance();
  static UserTranslationsProposal* default_instance_;
};
// -------------------------------------------------------------------

class Translations : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:roosha.translation.Translations) */ {
 public:
  Translations();
  virtual ~Translations();

  Translations(const Translations& from);

  inline Translations& operator=(const Translations& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Translations& default_instance();

  void Swap(Translations* other);

  // implements Message ----------------------------------------------

  inline Translations* New() const { return New(NULL); }

  Translations* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Translations& from);
  void MergeFrom(const Translations& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Translations* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string source = 1;
  void clear_source();
  static const int kSourceFieldNumber = 1;
  const ::std::string& source() const;
  void set_source(const ::std::string& value);
  void set_source(const char* value);
  void set_source(const char* value, size_t size);
  ::std::string* mutable_source();
  ::std::string* release_source();
  void set_allocated_source(::std::string* source);

  // repeated .roosha.translation.Translation translation = 2;
  int translation_size() const;
  void clear_translation();
  static const int kTranslationFieldNumber = 2;
  const ::roosha::translation::Translation& translation(int index) const;
  ::roosha::translation::Translation* mutable_translation(int index);
  ::roosha::translation::Translation* add_translation();
  ::google::protobuf::RepeatedPtrField< ::roosha::translation::Translation >*
      mutable_translation();
  const ::google::protobuf::RepeatedPtrField< ::roosha::translation::Translation >&
      translation() const;

  // @@protoc_insertion_point(class_scope:roosha.translation.Translations)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr source_;
  ::google::protobuf::RepeatedPtrField< ::roosha::translation::Translation > translation_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_roosha_5fservice_2eproto();
  friend void protobuf_AssignDesc_roosha_5fservice_2eproto();
  friend void protobuf_ShutdownFile_roosha_5fservice_2eproto();

  void InitAsDefaultInstance();
  static Translations* default_instance_;
};
// -------------------------------------------------------------------

class Translation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:roosha.translation.Translation) */ {
 public:
  Translation();
  virtual ~Translation();

  Translation(const Translation& from);

  inline Translation& operator=(const Translation& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Translation& default_instance();

  void Swap(Translation* other);

  // implements Message ----------------------------------------------

  inline Translation* New() const { return New(NULL); }

  Translation* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Translation& from);
  void MergeFrom(const Translation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Translation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string target = 1;
  int target_size() const;
  void clear_target();
  static const int kTargetFieldNumber = 1;
  const ::std::string& target(int index) const;
  ::std::string* mutable_target(int index);
  void set_target(int index, const ::std::string& value);
  void set_target(int index, const char* value);
  void set_target(int index, const char* value, size_t size);
  ::std::string* add_target();
  void add_target(const ::std::string& value);
  void add_target(const char* value);
  void add_target(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& target() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_target();

  // repeated string example = 2;
  int example_size() const;
  void clear_example();
  static const int kExampleFieldNumber = 2;
  const ::std::string& example(int index) const;
  ::std::string* mutable_example(int index);
  void set_example(int index, const ::std::string& value);
  void set_example(int index, const char* value);
  void set_example(int index, const char* value, size_t size);
  ::std::string* add_example();
  void add_example(const ::std::string& value);
  void add_example(const char* value);
  void add_example(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& example() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_example();

  // optional .roosha.translation.TranslationProvider provider = 3;
  void clear_provider();
  static const int kProviderFieldNumber = 3;
  ::roosha::translation::TranslationProvider provider() const;
  void set_provider(::roosha::translation::TranslationProvider value);

  // @@protoc_insertion_point(class_scope:roosha.translation.Translation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::std::string> target_;
  ::google::protobuf::RepeatedPtrField< ::std::string> example_;
  int provider_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_roosha_5fservice_2eproto();
  friend void protobuf_AssignDesc_roosha_5fservice_2eproto();
  friend void protobuf_ShutdownFile_roosha_5fservice_2eproto();

  void InitAsDefaultInstance();
  static Translation* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// TranslationRequest

// optional bytes token = 1;
inline bool TranslationRequest::has_token() const {
  return tokenOrId_case() == kToken;
}
inline void TranslationRequest::set_has_token() {
  _oneof_case_[0] = kToken;
}
inline void TranslationRequest::clear_token() {
  if (has_token()) {
    tokenOrId_.token_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_tokenOrId();
  }
}
inline const ::std::string& TranslationRequest::token() const {
  // @@protoc_insertion_point(field_get:roosha.translation.TranslationRequest.token)
  if (has_token()) {
    return tokenOrId_.token_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void TranslationRequest::set_token(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:roosha.translation.TranslationRequest.token)
  if (!has_token()) {
    clear_tokenOrId();
    set_has_token();
    tokenOrId_.token_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  tokenOrId_.token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:roosha.translation.TranslationRequest.token)
}
inline void TranslationRequest::set_token(const char* value) {
  if (!has_token()) {
    clear_tokenOrId();
    set_has_token();
    tokenOrId_.token_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  tokenOrId_.token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:roosha.translation.TranslationRequest.token)
}
inline void TranslationRequest::set_token(const void* value, size_t size) {
  if (!has_token()) {
    clear_tokenOrId();
    set_has_token();
    tokenOrId_.token_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  tokenOrId_.token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:roosha.translation.TranslationRequest.token)
}
inline ::std::string* TranslationRequest::mutable_token() {
  if (!has_token()) {
    clear_tokenOrId();
    set_has_token();
    tokenOrId_.token_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:roosha.translation.TranslationRequest.token)
  return tokenOrId_.token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TranslationRequest::release_token() {
  // @@protoc_insertion_point(field_release:roosha.translation.TranslationRequest.token)
  if (has_token()) {
    clear_has_tokenOrId();
    return tokenOrId_.token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void TranslationRequest::set_allocated_token(::std::string* token) {
  if (!has_token()) {
    tokenOrId_.token_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_tokenOrId();
  if (token != NULL) {
    set_has_token();
    tokenOrId_.token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        token);
  }
  // @@protoc_insertion_point(field_set_allocated:roosha.translation.TranslationRequest.token)
}

// optional uint64 id = 100;
inline bool TranslationRequest::has_id() const {
  return tokenOrId_case() == kId;
}
inline void TranslationRequest::set_has_id() {
  _oneof_case_[0] = kId;
}
inline void TranslationRequest::clear_id() {
  if (has_id()) {
    tokenOrId_.id_ = GOOGLE_ULONGLONG(0);
    clear_has_tokenOrId();
  }
}
inline ::google::protobuf::uint64 TranslationRequest::id() const {
  // @@protoc_insertion_point(field_get:roosha.translation.TranslationRequest.id)
  if (has_id()) {
    return tokenOrId_.id_;
  }
  return GOOGLE_ULONGLONG(0);
}
inline void TranslationRequest::set_id(::google::protobuf::uint64 value) {
  if (!has_id()) {
    clear_tokenOrId();
    set_has_id();
  }
  tokenOrId_.id_ = value;
  // @@protoc_insertion_point(field_set:roosha.translation.TranslationRequest.id)
}

// optional string source = 2;
inline void TranslationRequest::clear_source() {
  source_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TranslationRequest::source() const {
  // @@protoc_insertion_point(field_get:roosha.translation.TranslationRequest.source)
  return source_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TranslationRequest::set_source(const ::std::string& value) {
  
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:roosha.translation.TranslationRequest.source)
}
inline void TranslationRequest::set_source(const char* value) {
  
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:roosha.translation.TranslationRequest.source)
}
inline void TranslationRequest::set_source(const char* value, size_t size) {
  
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:roosha.translation.TranslationRequest.source)
}
inline ::std::string* TranslationRequest::mutable_source() {
  
  // @@protoc_insertion_point(field_mutable:roosha.translation.TranslationRequest.source)
  return source_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TranslationRequest::release_source() {
  // @@protoc_insertion_point(field_release:roosha.translation.TranslationRequest.source)
  
  return source_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TranslationRequest::set_allocated_source(::std::string* source) {
  if (source != NULL) {
    
  } else {
    
  }
  source_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), source);
  // @@protoc_insertion_point(field_set_allocated:roosha.translation.TranslationRequest.source)
}

inline bool TranslationRequest::has_tokenOrId() const {
  return tokenOrId_case() != TOKENORID_NOT_SET;
}
inline void TranslationRequest::clear_has_tokenOrId() {
  _oneof_case_[0] = TOKENORID_NOT_SET;
}
inline TranslationRequest::TokenOrIdCase TranslationRequest::tokenOrId_case() const {
  return TranslationRequest::TokenOrIdCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// UserTranslationsProposal

// optional bytes token = 1;
inline bool UserTranslationsProposal::has_token() const {
  return tokenOrId_case() == kToken;
}
inline void UserTranslationsProposal::set_has_token() {
  _oneof_case_[0] = kToken;
}
inline void UserTranslationsProposal::clear_token() {
  if (has_token()) {
    tokenOrId_.token_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_tokenOrId();
  }
}
inline const ::std::string& UserTranslationsProposal::token() const {
  // @@protoc_insertion_point(field_get:roosha.translation.UserTranslationsProposal.token)
  if (has_token()) {
    return tokenOrId_.token_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void UserTranslationsProposal::set_token(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:roosha.translation.UserTranslationsProposal.token)
  if (!has_token()) {
    clear_tokenOrId();
    set_has_token();
    tokenOrId_.token_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  tokenOrId_.token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:roosha.translation.UserTranslationsProposal.token)
}
inline void UserTranslationsProposal::set_token(const char* value) {
  if (!has_token()) {
    clear_tokenOrId();
    set_has_token();
    tokenOrId_.token_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  tokenOrId_.token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:roosha.translation.UserTranslationsProposal.token)
}
inline void UserTranslationsProposal::set_token(const void* value, size_t size) {
  if (!has_token()) {
    clear_tokenOrId();
    set_has_token();
    tokenOrId_.token_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  tokenOrId_.token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:roosha.translation.UserTranslationsProposal.token)
}
inline ::std::string* UserTranslationsProposal::mutable_token() {
  if (!has_token()) {
    clear_tokenOrId();
    set_has_token();
    tokenOrId_.token_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:roosha.translation.UserTranslationsProposal.token)
  return tokenOrId_.token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserTranslationsProposal::release_token() {
  // @@protoc_insertion_point(field_release:roosha.translation.UserTranslationsProposal.token)
  if (has_token()) {
    clear_has_tokenOrId();
    return tokenOrId_.token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void UserTranslationsProposal::set_allocated_token(::std::string* token) {
  if (!has_token()) {
    tokenOrId_.token_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_tokenOrId();
  if (token != NULL) {
    set_has_token();
    tokenOrId_.token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        token);
  }
  // @@protoc_insertion_point(field_set_allocated:roosha.translation.UserTranslationsProposal.token)
}

// optional uint64 id = 100;
inline bool UserTranslationsProposal::has_id() const {
  return tokenOrId_case() == kId;
}
inline void UserTranslationsProposal::set_has_id() {
  _oneof_case_[0] = kId;
}
inline void UserTranslationsProposal::clear_id() {
  if (has_id()) {
    tokenOrId_.id_ = GOOGLE_ULONGLONG(0);
    clear_has_tokenOrId();
  }
}
inline ::google::protobuf::uint64 UserTranslationsProposal::id() const {
  // @@protoc_insertion_point(field_get:roosha.translation.UserTranslationsProposal.id)
  if (has_id()) {
    return tokenOrId_.id_;
  }
  return GOOGLE_ULONGLONG(0);
}
inline void UserTranslationsProposal::set_id(::google::protobuf::uint64 value) {
  if (!has_id()) {
    clear_tokenOrId();
    set_has_id();
  }
  tokenOrId_.id_ = value;
  // @@protoc_insertion_point(field_set:roosha.translation.UserTranslationsProposal.id)
}

// optional .roosha.translation.Translations proposedTranslations = 2;
inline bool UserTranslationsProposal::has_proposedtranslations() const {
  return !_is_default_instance_ && proposedtranslations_ != NULL;
}
inline void UserTranslationsProposal::clear_proposedtranslations() {
  if (GetArenaNoVirtual() == NULL && proposedtranslations_ != NULL) delete proposedtranslations_;
  proposedtranslations_ = NULL;
}
inline const ::roosha::translation::Translations& UserTranslationsProposal::proposedtranslations() const {
  // @@protoc_insertion_point(field_get:roosha.translation.UserTranslationsProposal.proposedTranslations)
  return proposedtranslations_ != NULL ? *proposedtranslations_ : *default_instance_->proposedtranslations_;
}
inline ::roosha::translation::Translations* UserTranslationsProposal::mutable_proposedtranslations() {
  
  if (proposedtranslations_ == NULL) {
    proposedtranslations_ = new ::roosha::translation::Translations;
  }
  // @@protoc_insertion_point(field_mutable:roosha.translation.UserTranslationsProposal.proposedTranslations)
  return proposedtranslations_;
}
inline ::roosha::translation::Translations* UserTranslationsProposal::release_proposedtranslations() {
  // @@protoc_insertion_point(field_release:roosha.translation.UserTranslationsProposal.proposedTranslations)
  
  ::roosha::translation::Translations* temp = proposedtranslations_;
  proposedtranslations_ = NULL;
  return temp;
}
inline void UserTranslationsProposal::set_allocated_proposedtranslations(::roosha::translation::Translations* proposedtranslations) {
  delete proposedtranslations_;
  proposedtranslations_ = proposedtranslations;
  if (proposedtranslations) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:roosha.translation.UserTranslationsProposal.proposedTranslations)
}

inline bool UserTranslationsProposal::has_tokenOrId() const {
  return tokenOrId_case() != TOKENORID_NOT_SET;
}
inline void UserTranslationsProposal::clear_has_tokenOrId() {
  _oneof_case_[0] = TOKENORID_NOT_SET;
}
inline UserTranslationsProposal::TokenOrIdCase UserTranslationsProposal::tokenOrId_case() const {
  return UserTranslationsProposal::TokenOrIdCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Translations

// optional string source = 1;
inline void Translations::clear_source() {
  source_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Translations::source() const {
  // @@protoc_insertion_point(field_get:roosha.translation.Translations.source)
  return source_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Translations::set_source(const ::std::string& value) {
  
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:roosha.translation.Translations.source)
}
inline void Translations::set_source(const char* value) {
  
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:roosha.translation.Translations.source)
}
inline void Translations::set_source(const char* value, size_t size) {
  
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:roosha.translation.Translations.source)
}
inline ::std::string* Translations::mutable_source() {
  
  // @@protoc_insertion_point(field_mutable:roosha.translation.Translations.source)
  return source_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Translations::release_source() {
  // @@protoc_insertion_point(field_release:roosha.translation.Translations.source)
  
  return source_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Translations::set_allocated_source(::std::string* source) {
  if (source != NULL) {
    
  } else {
    
  }
  source_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), source);
  // @@protoc_insertion_point(field_set_allocated:roosha.translation.Translations.source)
}

// repeated .roosha.translation.Translation translation = 2;
inline int Translations::translation_size() const {
  return translation_.size();
}
inline void Translations::clear_translation() {
  translation_.Clear();
}
inline const ::roosha::translation::Translation& Translations::translation(int index) const {
  // @@protoc_insertion_point(field_get:roosha.translation.Translations.translation)
  return translation_.Get(index);
}
inline ::roosha::translation::Translation* Translations::mutable_translation(int index) {
  // @@protoc_insertion_point(field_mutable:roosha.translation.Translations.translation)
  return translation_.Mutable(index);
}
inline ::roosha::translation::Translation* Translations::add_translation() {
  // @@protoc_insertion_point(field_add:roosha.translation.Translations.translation)
  return translation_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::roosha::translation::Translation >*
Translations::mutable_translation() {
  // @@protoc_insertion_point(field_mutable_list:roosha.translation.Translations.translation)
  return &translation_;
}
inline const ::google::protobuf::RepeatedPtrField< ::roosha::translation::Translation >&
Translations::translation() const {
  // @@protoc_insertion_point(field_list:roosha.translation.Translations.translation)
  return translation_;
}

// -------------------------------------------------------------------

// Translation

// repeated string target = 1;
inline int Translation::target_size() const {
  return target_.size();
}
inline void Translation::clear_target() {
  target_.Clear();
}
inline const ::std::string& Translation::target(int index) const {
  // @@protoc_insertion_point(field_get:roosha.translation.Translation.target)
  return target_.Get(index);
}
inline ::std::string* Translation::mutable_target(int index) {
  // @@protoc_insertion_point(field_mutable:roosha.translation.Translation.target)
  return target_.Mutable(index);
}
inline void Translation::set_target(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:roosha.translation.Translation.target)
  target_.Mutable(index)->assign(value);
}
inline void Translation::set_target(int index, const char* value) {
  target_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:roosha.translation.Translation.target)
}
inline void Translation::set_target(int index, const char* value, size_t size) {
  target_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:roosha.translation.Translation.target)
}
inline ::std::string* Translation::add_target() {
  // @@protoc_insertion_point(field_add_mutable:roosha.translation.Translation.target)
  return target_.Add();
}
inline void Translation::add_target(const ::std::string& value) {
  target_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:roosha.translation.Translation.target)
}
inline void Translation::add_target(const char* value) {
  target_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:roosha.translation.Translation.target)
}
inline void Translation::add_target(const char* value, size_t size) {
  target_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:roosha.translation.Translation.target)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Translation::target() const {
  // @@protoc_insertion_point(field_list:roosha.translation.Translation.target)
  return target_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Translation::mutable_target() {
  // @@protoc_insertion_point(field_mutable_list:roosha.translation.Translation.target)
  return &target_;
}

// repeated string example = 2;
inline int Translation::example_size() const {
  return example_.size();
}
inline void Translation::clear_example() {
  example_.Clear();
}
inline const ::std::string& Translation::example(int index) const {
  // @@protoc_insertion_point(field_get:roosha.translation.Translation.example)
  return example_.Get(index);
}
inline ::std::string* Translation::mutable_example(int index) {
  // @@protoc_insertion_point(field_mutable:roosha.translation.Translation.example)
  return example_.Mutable(index);
}
inline void Translation::set_example(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:roosha.translation.Translation.example)
  example_.Mutable(index)->assign(value);
}
inline void Translation::set_example(int index, const char* value) {
  example_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:roosha.translation.Translation.example)
}
inline void Translation::set_example(int index, const char* value, size_t size) {
  example_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:roosha.translation.Translation.example)
}
inline ::std::string* Translation::add_example() {
  // @@protoc_insertion_point(field_add_mutable:roosha.translation.Translation.example)
  return example_.Add();
}
inline void Translation::add_example(const ::std::string& value) {
  example_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:roosha.translation.Translation.example)
}
inline void Translation::add_example(const char* value) {
  example_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:roosha.translation.Translation.example)
}
inline void Translation::add_example(const char* value, size_t size) {
  example_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:roosha.translation.Translation.example)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Translation::example() const {
  // @@protoc_insertion_point(field_list:roosha.translation.Translation.example)
  return example_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Translation::mutable_example() {
  // @@protoc_insertion_point(field_mutable_list:roosha.translation.Translation.example)
  return &example_;
}

// optional .roosha.translation.TranslationProvider provider = 3;
inline void Translation::clear_provider() {
  provider_ = 0;
}
inline ::roosha::translation::TranslationProvider Translation::provider() const {
  // @@protoc_insertion_point(field_get:roosha.translation.Translation.provider)
  return static_cast< ::roosha::translation::TranslationProvider >(provider_);
}
inline void Translation::set_provider(::roosha::translation::TranslationProvider value) {
  
  provider_ = value;
  // @@protoc_insertion_point(field_set:roosha.translation.Translation.provider)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace translation
}  // namespace roosha

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::roosha::translation::TranslationProvider> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::roosha::translation::TranslationProvider>() {
  return ::roosha::translation::TranslationProvider_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_roosha_5fservice_2eproto__INCLUDED
