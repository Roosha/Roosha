#!/usr/bin/env python3
import argparse
import sys
import re

from pathlib import Path


def eprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)
    exit(-1)


# --------------------parse arguments-------------------
parser = argparse.ArgumentParser(description="Add generated by protobuf classes in QMetatype.\n"
                                             "For further documentation, see: "
                                             "http://doc.qt.io/qt-5/qmetatype.html#Q_DECLARE_METATYPE\n")
parser.add_argument("-i", "--proto_dir",
                    type=str, default="",
                    action="store", dest="proto",
                    help="directory which contains .proto files",
                    )
parser.add_argument("-o", "--headers_dir",
                    type=str, default="",
                    action="store", dest="headers",
                    help="directory which contains .pb.h files",
                    )
ARGS = parser.parse_args()
# -------------------------------------------------------
# ----------------------find files-----------------------
proto_path = (Path(".") / ARGS.proto)
headers_path = (Path(".") / ARGS.headers)
for path in (proto_path, headers_path):
    if not path.is_dir():
        eprint("Error: {} is not a directory".format(path))

PROTO_FILES = {x.name.replace("".join(x.suffixes), ""): x
               for x in proto_path.glob("*.proto")}
HEADERS_FILES = {x.name.replace("".join(x.suffixes), ""): x
                 for x in filter(lambda x: '.grpc' not in x.suffixes, headers_path.glob("*.pb.h"))}
# print(PROTO_FILES, HEADERS_FILES, sep="\n")
if PROTO_FILES.keys() != HEADERS_FILES.keys():
    eprint("Error: .proto and .pb.h files don't match:",
           "Proto files:", ",\n".join(x.name for x in PROTO_FILES.values()),
           "Header files:", ",\n".join(x.name for x in HEADERS_FILES.values())
           )


# -------------------------------------------------------
# --------------extract packages and messages------------


def extract_package(path):
    pkg_re = re.compile(r"package\s+((\w+)(\.\w+)+)")
    with path.open() as file:
        for line in file:
            line = line.strip()
            match = pkg_re.match(line)
            if match:
                return match.group(1)
    return ""


def extract_messages(path):
    msg_re = re.compile(r"message\s+(\w+)")
    with path.open() as file:
        for line in file:
            line = line.strip()
            match = msg_re.match(line)
            if match:
                yield match.group(1)


FILE_MESSAGES = {}
FILE_NAMESPACES = {}
for name, path in PROTO_FILES.items():
    pkg = extract_package(path)
    FILE_NAMESPACES[name] = pkg.split('.')
    namespace = "::" + pkg.replace(".", "::")
    FILE_MESSAGES[name] = tuple(namespace + "::" + x for x in extract_messages(path))
# print(FILE_NAMESPACES)
# print(FILE_MESSAGES)


# -------------------------------------------------------


def namespaces_closing_brace(path, namespaces):
    namespaces = tuple(reversed(namespaces))
    closing_brace_re = lambda nsn: re.compile(r"}\s+//\s+namespace\s+" + nsn)
    cur = 0
    count = 0
    with path.open() as file:
        for line in file:
            if cur == len(namespaces):
                return count
            count += 1

            match = closing_brace_re(namespaces[cur]).match(line)
            if match:
                cur += 1
    if cur != len(namespaces):
        eprint("Error while parsing file ",
               path.name, ":\n",
               "Could not find namespace closing brace\n",
               "cur = ", cur, ", count = ", count,
               sep="")


for name, path in HEADERS_FILES.items():
    namespace = FILE_NAMESPACES[name]
    insertion_line = namespaces_closing_brace(path, namespace)
    insertions = ["Q_DECLARE_METATYPE({})\n".format(x) for x in FILE_MESSAGES[name]]

    lines = []
    with path.open(mode="r") as file:
        lines += file.readlines()
    lines = ["#include <QMetaType>\n"] + lines[:insertion_line] + insertions + lines[insertion_line:]
    with path.open(mode="w") as file:
        file.write("".join(lines))
